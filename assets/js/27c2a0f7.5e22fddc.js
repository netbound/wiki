"use strict";(self.webpackChunkalexandria=self.webpackChunkalexandria||[]).push([[816],{7912:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return h},metadata:function(){return m},toc:function(){return l},default:function(){return p}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),i=["components"],s={},h="Ownership and Borrowing",m={unversionedId:"rust/ownership-borrowing",id:"rust/ownership-borrowing",isDocsHomePage:!1,title:"Ownership and Borrowing",description:"Memory Management",source:"@site/docs/rust/ownership-borrowing.md",sourceDirName:"rust",slug:"/rust/ownership-borrowing",permalink:"/rust/ownership-borrowing",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/rust/ownership-borrowing.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Setting up Wireguard on an EdgeRouter 4",permalink:"/networking/wireguard-er"}},l=[{value:"Memory Management",id:"memory-management",children:[{value:"Stack",id:"stack",children:[]},{value:"Heap",id:"heap",children:[]},{value:"Approaches to memory management",id:"approaches-to-memory-management",children:[]}]},{value:"MM in Rust: Ownership",id:"mm-in-rust-ownership",children:[]},{value:"Sources",id:"sources",children:[]}],u={toc:l};function p(e){var t=e.components,s=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"ownership-and-borrowing"},"Ownership and Borrowing"),(0,o.kt)("h2",{id:"memory-management"},"Memory Management"),(0,o.kt)("p",null,"Memory management is something that's handled differently according to the programming language. For a running program\nthere are two areas of RAM it can use to store data: the stack and the heap."),(0,o.kt)("h3",{id:"stack"},"Stack"),(0,o.kt)("p",null,"The stack is used for ",(0,o.kt)("strong",{parentName:"p"},"static")," memory allocation, and it uses a LIFO (last in, first out) data structure.\nEach running thread has its own stack, as well as a register that points to the current top of the stack: the ",(0,o.kt)("strong",{parentName:"p"},"stack pointer"),".\nAccessing and storing data on the stack is very efficient: it's as easy as pushing onto or popping values off the stack.\nYou can't store everything on the stack though, only data that is of a known and fixed size.\nWhen a program is running, this is what its stack might look like:\n",(0,o.kt)("img",{alt:"Call stack",src:a(1998).Z})),(0,o.kt)("p",null,"Each function gets its own stack frame, which is an area that is populated by the ",(0,o.kt)("strong",{parentName:"p"},"return address of the calling function"),", the\n",(0,o.kt)("strong",{parentName:"p"},"function arguments")," and the ",(0,o.kt)("strong",{parentName:"p"},"static data and pointers in the function scope"),". When a function returns to the return address specified at the bottom of the current stack frame, all the values in the stack frame are popped off. This is done by the OS, and is not something programmers need to think about. As you can see in the image, the stack grows ",(0,o.kt)("strong",{parentName:"p"},"downwards"),".\nA ",(0,o.kt)("strong",{parentName:"p"},"stack overflow")," error happens when the call stack of a program exceeds the maximum size of the stack."),(0,o.kt)("h3",{id:"heap"},"Heap"),(0,o.kt)("p",null,"The heap is an unstructured blob of data that is used for ",(0,o.kt)("strong",{parentName:"p"},"dynamic memory allocation"),". When you want to create something that has\nan unknown size at compile time (a Rust ",(0,o.kt)("inlineCode",{parentName:"p"},"Vec"),", for example), it will be stored on the heap and referenced by a memory address\n(",(0,o.kt)("strong",{parentName:"p"},"pointer"),"). There are a couple big differences with the stack:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Looking up data on the heap is ",(0,o.kt)("strong",{parentName:"li"},"slower")," than on the stack."),(0,o.kt)("li",{parentName:"ul"},"The heap is ",(0,o.kt)("strong",{parentName:"li"},"shared")," among application threads."),(0,o.kt)("li",{parentName:"ul"},"Managing data on the heap is not done by the OS, and is either the task of the programmer or the programming language.\nA lot of bugs originate from mismanaging data on the heap."),(0,o.kt)("li",{parentName:"ul"},"Stores more complex data types (",(0,o.kt)("inlineCode",{parentName:"li"},"String"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Vec"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"HashMap"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Box"),") and global variables.")),(0,o.kt)("h3",{id:"approaches-to-memory-management"},"Approaches to memory management"),(0,o.kt)("p",null,"We look at the 2 main approaches: manual memory management and garbage collection. If you are interested, these are some of the other\n(less common) ones: RAII (Resource Acquisition is Initialization) and ARC (Automatic Reference Counting)."),(0,o.kt)("h4",{id:"manual-memory-management"},"Manual memory management"),(0,o.kt)("p",null,"You have to manually allocate and free memory, and make sure you're causing\nmemory bugs like dangling pointers or use-after-free errors. Languages that fall under this category are C and C++.\nThe standard library provides you with the ",(0,o.kt)("inlineCode",{parentName:"p"},"malloc"),"-type functions to allocate as well as ",(0,o.kt)("inlineCode",{parentName:"p"},"free")," to free memory on the heap."),(0,o.kt)("h4",{id:"garbage-collection-gc"},"Garbage Collection (GC)"),(0,o.kt)("p",null,"Automatic freeing of unused heap memory. This is part of the runtime of the language and runs at intervals, which can cause\na slight overhead. A lot of modern languages use this approach: JavaScript, C#, Golang, Ruby, Java (and JVM languages)."),(0,o.kt)("h2",{id:"mm-in-rust-ownership"},"MM in Rust: Ownership"),(0,o.kt)("h2",{id:"sources"},"Sources"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html"},"Rust Book on Ownership"))))}p.isMDXComponent=!0},1998:function(e,t,a){t.Z=a.p+"assets/images/callstack-63c1d2e2a41cfae1c594e5b1821f3690.png"}}]);