"use strict";(self.webpackChunkalexandria=self.webpackChunkalexandria||[]).push([[621],{9628:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return l},default:function(){return p}});var o=t(7462),a=t(3366),r=(t(7294),t(3905)),i=["components"],c={},u="Concurrency in Go",s={unversionedId:"go/concurrency-in-go",id:"go/concurrency-in-go",isDocsHomePage:!1,title:"Concurrency in Go",description:"Communicating Sequential Processes",source:"@site/docs/go/concurrency-in-go.md",sourceDirName:"go",slug:"/go/concurrency-in-go",permalink:"/go/concurrency-in-go",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/go/concurrency-in-go.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Staking on Ethereum with Rocketpool",permalink:"/ethereum/staking"},next:{title:"Go Performance",permalink:"/go/go-performance"}},l=[{value:"Communicating Sequential Processes",id:"communicating-sequential-processes",children:[]},{value:"Goroutines",id:"goroutines",children:[]},{value:"Channels",id:"channels",children:[]},{value:"Sources",id:"sources",children:[]}],h={toc:l};function p(e){var n=e.components,t=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"concurrency-in-go"},"Concurrency in Go"),(0,r.kt)("h2",{id:"communicating-sequential-processes"},"Communicating Sequential Processes"),(0,r.kt)("p",null,"Go concurrency is based on ",(0,r.kt)("a",{parentName:"p",href:"https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf"},"Communicating Sequential Processes"),", a paper\nfrom C.A.R. Hoare, in 1978."),(0,r.kt)("p",null,"Go has 4 tools to achieve concurrency:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Go routines"),(0,r.kt)("li",{parentName:"ul"},"Channels"),(0,r.kt)("li",{parentName:"ul"},"Select"),(0,r.kt)("li",{parentName:"ul"},"Sync package")),(0,r.kt)("p",null,"We'll go over all 4 of them in depth."),(0,r.kt)("h2",{id:"goroutines"},"Goroutines"),(0,r.kt)("h2",{id:"channels"},"Channels"),(0,r.kt)("p",null,"Channels can be thought of as a bucket chain. We have a ",(0,r.kt)("strong",{parentName:"p"},"sender"),", passing buckets down the chain, the ",(0,r.kt)("strong",{parentName:"p"},"buffer"),",\nwhich is the chain itself, and then the ",(0,r.kt)("strong",{parentName:"p"},"receiver"),". The buffer is optional. It helps to think of channels as data streams,\nand there are a lot of patterns that follow from this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Fan-out"),(0,r.kt)("li",{parentName:"ul"},"Funnel"),(0,r.kt)("li",{parentName:"ul"},"Turnout")),(0,r.kt)("p",null,"There's a lot of situations where channels can be blocking. Here are some examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"unbuffered := make(chan int)\n\n// This blocks, no receiver\nunbuffered <- 1\n// This also blocks, no sender\ni := <- unbuffered\n\n// We have to add a receiver in a separate goroutine:\ngo func() {\n    i := <- unbuffered\n}()\n\n// This will synchronise both goroutines\nunbuffered <- 1\n")),(0,r.kt)("p",null,"Channels can be closed. This should ",(0,r.kt)("strong",{parentName:"p"},"always")," happen on the sender side!"),(0,r.kt)("h2",{id:"sources"},"Sources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=YEKjSzIwAdA"},"Concurrency Patterns in Go [Video]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=f6kdp27TYZs"},"Concurrency Patterns in Go - Google I/O [Video]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=DqHb5KBe7qI"},"Concurrency made easy [Video]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf"},"Communicating Sequential Process [PDF]"))))}p.isMDXComponent=!0}}]);